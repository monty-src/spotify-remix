import { Command } from 'commander';

type CommandMetadata = {
  name: string;
  description?: string;
};

type CommandMethod = (this: MyCLI, ...args: any[]) => any;

type CommandOptions = {
  name: string;
  description?: string;
  action: CommandMethod;
};

function command(options: CommandMetadata): MethodDecorator {
  return function(target: any, key: string, descriptor: PropertyDescriptor) {
    // Get the existing commands metadata for the class, or create a new one
    const commands = target.constructor.__commands || {};
    const method = descriptor.value as CommandMethod;

    // Add the new command metadata for the method
    commands[key] = { name: options.name, description: options.description, action: method };
    target.constructor.__commands = commands;
  };
}

function cliProgram(): ClassDecorator {
  return function(target: any) {
    // Create a new Commander program
    const program = new Command();

    // Get the commands metadata for the class
    const commands = target.__commands || {};

    // Create commands for each method of the class with command metadata
    for (const [key, metadata] of Object.entries(commands)) {
      const command = new Command();
      command.name(metadata.name);
      if (metadata.description) {
        command.description(metadata.description);
      }
      command.action(metadata.action.bind(target));
      program.addCommand(command);
    }

    // Parse the command-line arguments and execute the corresponding command
    program.parse(process.argv);
  };
}

@cliProgram()
class MyCLI {
  @command({ name: 'greet [name]', description: 'Greet the user' })
  greet(name?: string) {
    console.log(`Hello, ${name || 'world'}!`);
  }

  @command({ name: 'echo [message]', description: 'Echo the message' })
  echo(message?: string) {
    console.log(message || 'No message provided');
  }
}